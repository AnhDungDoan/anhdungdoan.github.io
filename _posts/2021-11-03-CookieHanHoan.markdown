---
layout: post
title: CookieHanHoan
date: 2021-11-03 00:00:00 +0300
description: WU Crypto # Add post description (optional)
img: CKHH.png # Add image post (optional)
tags: [Crypto, CTF] # add tag
---

# C√∫c ki h√¢n hoan

Ch√†o c√°c anh em, gi·∫£i n√†y c·ªßng c·ªë ki·∫øn th·ª©c kha kh√° n√™n l√†m vui l·∫Øm c√°c anh em √† <3 

# XOR (146 solves)
> XOR
![image.png](/assets/img/CKHH/xor.png)

encrypt.py
```
flag = ###SECRET###
key = ###SECRET###
assert len(key) == 1

def encrypt(a,b):
    return ''.join([hex(ord(b[i%len(b)]) ^ ord(a[i]))[2:] for i in range(0,len(a))])

with open('cipher.txt', 'w') as f:
	f.write(encrypt(flag, key))
```

cipher.txt
```
6c464b4d514b744817491714487449174b57
```

**Solve:**
- ·ªû encrypt.py, ƒë∆°n gi·∫£n l√† ch·ªâ encrypt flag c·ªßa m√¨nh v√† key, sau ƒë√≥ in ra cipher d∆∞·ªõi d·∫°ng m√£ hex.
- ƒê∆°n gi·∫£n h√≥a v·∫•n ƒë·ªÅ khi m√¨nh xem ·ªü file encrypt l√† ƒë·ªô d√†i c·ªßa key = 1. V·∫≠y m√¨nh ch·ªâ c·∫ßn bruteforce key l√† c√≥ th·ªÉ t√¨m ra ƒë∆∞·ª£c Flag n√†o c√≥ format "Flag{XXXXXX}" l√† ƒë√∫ng ·ªùi üòé

solve.py
```
import string
def encrypt(a,b):
    return ''.join([chr(ord(b[i%len(b)]) ^ ord(a[i])) for i in range(0,len(a))])

cipher = bytes.fromhex("6c464b4d514b744817491714487449174b57").decode()

for key in string.printable:
    flag = encrypt(cipher, key)
    if ('Flag' in flag):
        print(flag)
```

>FLAG: Flag{a^b=c=>b^c=a}


# MORSE (218 solves)
> Su·ªµt! T·∫≠p trung v√† ƒëeo tai nghe l√™n n√†o. G√† c√≥ nghe th·∫•y nh·ªãp beat kh√¥ng? H·ªç n√≥i g√¨ t·ª´ b√™n kia chi·∫øn tuy·∫øn Format: Flag{what_you_find}
![image.png](/assets/img/CKHH/morse.png)

**Solve:**
B√†i n√†y cho m√¨nh 1 file √¢m thanh <m√£ morse>. M√¨nh qu·∫≥ng l√™n tool l√† c√≥ ngay ph·ªù l√°c ‚úå

link tool: https://morsecode.world/international/decoder/audio-decoder-adaptive.html

![image.png](/assets/img/CKHH/morsesolve.png)

>FLAG: Flag{M.O.R.S.E.C.O.D.E}

# Julius Caesar (233 solves)
> V√¥ t√¨nh khi khai qu·∫≠t kh·∫£o c·ªï, G√† t√¨m ƒë∆∞·ª£c m·ªôt th√¥ng ƒëi·ªáp b√≠ ·∫©n kho·∫£ng h∆°n 100 nƒÉm tr∆∞·ªõc c√¥ng nguy√™n. Nghe ƒë·ªìn ƒë√¢y l√† m·ªôt b√≠ thu·∫≠t ƒë√£ b·ªã thay ƒë·ªïi c√¥ng th·ª©c c·ªßa m·ªôt v·ªã t∆∞·ªõng Julius Caesar, sau n√†y tr·ªü th√†nh v·ªã vua ƒë·∫ßu ti√™n c·ªßa ƒë·∫ø ch·∫ø La M√£ h√πng m·∫°nh. H√£y gi√∫p G√† gi·∫£i m·∫≠t th∆∞ n√†y!

![image.png](/assets/img/CKHH/caesar.png)

cipher.txt
```
Synt{Ry_Pynfvpb_Pvcure}
```

**Solve:**
- Nh·ªØng b√†i c√≥ d·∫•u hi·ªáu nh·∫≠n bi·∫øt r√µ r√†ng nh∆∞ th·∫ø n√†y th√¨ m√¨nh nghƒ© n√™n quƒÉng l√™n tool cho l·∫π, ti·∫øt ki·ªám th·ªùi gian, ƒë·ªô ch√≠nh x√°c tuy·ªát ƒë·ªëi he he 

link tool: https://www.dcode.fr/shift-cipher

![image.png](/assets/img/CKHH/caesarsolve.png)

Flag k√¨a l·ª•m ngay~~~

>FLAG: Flag{El_Clasico_Cipher}

# Sixty Four (203 solves)
> G√† ƒë·ªÉ l·∫°i m·ªôt th√¥ng ƒëi·ªáp b√≠ m·∫≠t nh∆∞ng n√≥ kh√¥ng l√†m kh√≥ ƒë∆∞·ª£c tr√≠ th√¥ng minh c·ªßa M√®o Yang H·ªì.

cipher.txt
```
NDY2QzYxNjc3QjVGNUY1RjQyNjE3MzY1MzYzNDc4NDg2NTc4NUY1RjVGN0Q=
```

**Solve:**
- Nh√¨n ph√°t bi·∫øt ngay l√† m√£ base64 =))). Th·∫ø l√† m√¨nh l·∫°i l·ª•m n√≥ quƒÉng v√¥ tool l√† l√° la...

![image.png](/assets/img/CKHH/64solve1.png)

- ∆†, kh√¥ng ra √†, nh∆∞ng m√¨nh ƒë∆∞·ª£c 1 ƒëo·∫°n m√£ kh√°c, ƒë√≥ l√† m√£ hex th√¨ ph·∫£i, m√¨nh quƒÉng v√¥ decode hex lu√¥n cho n√≥ nhanh

![image.png](/assets/img/CKHH/64solve2.png)
- Poong~ l·ª•m ti·ªÅn

link tool: https://gchq.github.io/CyberChef/
>FLAG: Flag{___Base64xHex___}

# Bruh AES (33 solves)

>√îi kh√¥ng, Hazy l·ª° xo√° ƒëi m·ªôt m·∫£nh gh√©p trong qu√° tr√¨nh m√£ ho√° AES m·∫•t r·ªìi :)

![image.png](/assets/img/CKHH/aes.png)

>ƒê√¢y l√† m·ªôt b√†i g√¢y kh√≥ ch·ªãu v·ªõi m√¨nh nh·∫•t. Kh√¥ng ph·∫£i v√¨ technique ƒë·ªÉ solve, m√† l√† c√°ch t√¨m Flag ƒë·ªÉ n·ªôp.

aes.py
```
import base64
from Crypto.Cipher import AES

#flag = ###FINDME###
algorithm = AES.MODE_CBC
key = 'supersecretkey!?'
iv_part1 = "0xcafedeadbeef"
iv_part2 = ###FINDME###"" 
iv = iv_part1 + iv_part2
#assert(len(flag)) == 38

def encrypt(payload, key, iv):
    return AES.new(key, algorithm, iv).encrypt(r_pad(payload))

def r_pad(payload, block_size=16):
    length = block_size - (len(payload) % block_size)
    return payload + chr(length) * length

with open('cipher.txt', 'wb') as f:
    f.write(encrypt(flag, key, iv)) 
```

**Problem:**
- M√¨nh ƒëi qua l√Ω thuy·∫øt v·ªÅ AES mode CBC 1 ch√∫t:

![image.png](/assets/img/CKHH/aescbc.png)

- Th√¨ c√°c anh em c√≥ th·ªÉ th·∫•y, block ƒë·∫ßu ti√™n c·ªßa plaintext s·∫Ω xor qua IV, sau ƒë√≥ v√†o 1 ƒë·ªëng vi·ªác t√≠nh to√°n ph·ª©c t·∫°p c·ªßa AES, cho ra 1 block cipher, sau ƒë√≥ d√πng ƒë·ªÉ xor v·ªõi block th·ª© 2 c·ªßa plaintext and go on.....
- Nh∆∞ng ·ªü file aes.py m√¨nh down v·ªÅ, c√≥ th·∫ø th·∫•y iv_part1 c√≥ ƒë·ªô d√†i l√† 14. Trong khi 1 block c√≥ ƒë·ªô d√†i l√† 16, th√¨ vi·ªác m√¨nh c·∫ßn l√†m l√† t√¨m 2 k√≠ t·ª± cu·ªëi c·ªßa IV. Gud x·ªù kiu l·∫°i l√† brute-force üòú

solve.py
```
iv_part1 = "0xcafedeadbeef"

import sys
import base64
import string 
from Crypto.Cipher import AES

key = b'supersecretkey!?'
sys.stdin = open("cipher.txt", "rb")
sys.stdout = open("flag.txt", "w")
algorithm = AES.MODE_CBC

def decrypt(payload, key, iv):
    cip = AES.new(key, algorithm, iv)
    return cip.decrypt(payload)

cipher = input()

for i in string.printable:
    for j in string.printable:
        iv = iv_part1 + i + j
        enc = decrypt(cipher, key, iv.encode())
        ans = enc[:38].decode()
        if (ans[15] in string.hexdigits and ans[14] in string.hexdigits):
            print("iv :", iv, "flag:", ans)    
```

*ch·ªó ans=enc[:38] l√† m√¨nh ch√¥m 38 k√≠ t·ª± ƒë·∫ßu th√¥i do flag m·ªói 38 k√≠ t·ª±*

- M√¨nh in ra file t√™n l√† *flag.txt*. Nh√¨n xemmmmmmmmmmmmmmm

![image.png](/assets/img/CKHH/aesflag.png)

- ∆†? Th·∫ø c√°i n√†o m·ªõi l√† flag ƒë√∫ng? M√¨nh ƒëi h·ªèi admin v·ªÅ flag c·ª• th·ªÉ nh∆∞ng kh√¥ng ƒÉn thua... Ph·∫£i t·ª± m√≤ v·∫≠y

- Hmm n√≥i chung l√† 2 ksi t·ª± cu·ªëi c·ªßa iv l√† 'x0', ƒë·ªìng nghƒ©a l√† m√¨nh t√¨m ƒë∆∞·ª£c Flag. C√≤n l√Ω do v√¨ sao l√† 'x0' √°? V√¨ n√≥ ƒë·ªëi x·ª©ng v·ªõi 2 k√≠ t·ª± ƒë·∫ßu c·ªßa IV ü§î. *superguesser*

>FLAG: Flag{f4edced3a1c3e72be1257f232a7a78b6}

# Cry more (19 solves)
>M√£ mua d√†i qu√° n√™n kh√¥ng mua ƒë∆∞·ª£c :(
>B·∫°n c√≥ th·ªÉ mua flag h·ªô Hazy ƒë∆∞·ª£c kh√¥ng :D
> nc chal1.crypto.letspentest.org 7000

![image.png](/assets/img/CKHH/crymore.png)

server.py
```
import datetime
import os
import random
import socketserver
import sys
from base64 import b64decode, b64encode
from hashlib import sha512


def get_flag():
    try:
        with open('flag.txt', 'rb') as f:
            flag = f.read()
            return flag
    except Exception as e:
        print(e)
        return b'Server is not configured correctly. Please contact admins to fix the problem'


items = [
    (b'Fowl x 3', 1),
    (b'Mora x 30000', 100),
    (b'Mystic Enhancement Ore x 5', 500),
    (b'Hero\'s Wits x 3', 1000),
    (b'Primogems x 40', 5000),
    (b'FLAG', 99999)
]


class RequestHandler(socketserver.StreamRequestHandler):

    def handle(self):
        self.signkey = os.urandom(random.randint(8, 32))
        self.money = random.randint(1, 2000)
        try:
            while True:
                self.menu()

                try:
                    self.request.sendall(b'Your choice: ')
                    opt = int(self.rfile.readline().decode())
                except ValueError:
                    self.request.sendall(
                        b'THIS IS A CRYPTOGRAPHIC CHALLENGE!!!\n')
                    continue
                if opt == 1:
                    self.list()
                elif opt == 2:
                    self.order()
                elif opt == 3:
                    self.confirm()
                elif opt == 4:
                    self.request.sendall(b'Bye~\n')
                    return
                else:
                    self.request.sendall(b'Ohh~\n')

        except (ConnectionResetError, ConnectionAbortedError, BrokenPipeError):
            print("{} disconnected".format(self.client_address[0]))

    def menu(self):
        self.request.sendall(
            b'To celebrate `our` first anniversary, we are offering you tons of product at the best prices\n')
        self.request.sendall(b'You have $%d\n' % self.money)
        self.request.sendall(b'1. Available products\n')
        self.request.sendall(b'2. Order\n')
        self.request.sendall(b'3. Confirm order\n')
        self.request.sendall(b'4. Exit\n')

    def list(self):
        for idx, item in enumerate(items):
            self.request.sendall(b'%d - %s: $%d\n' %
                                 (idx + 1, item[0], item[1]))

    def order(self):
        try:
            self.request.sendall(b'ID: ')
            pid = int(self.rfile.readline().decode())
        except ValueError:
            self.request.sendall(
                b'THIS IS A CRYPTOGRAPHIC CHALLENGE!!!\n')
            return

        if pid < 1 or pid > len(items):
            self.request.sendall(b'Ohh~\n')
            return

        payment = b'product=%s&price=%d&time=%.02f' % (
            items[pid-1][0], items[pid-1][1], datetime.datetime.now().timestamp())
        signature = sha512(self.signkey+payment).hexdigest()
        payment += b'&sign=%s' % signature.encode()
        self.request.sendall(b'Your order: ')
        self.request.sendall(b64encode(payment))
        self.request.sendall(b'\n')

    def confirm(self):
        try:
            self.request.sendall(b'Your order: ')
            payment = b64decode(self.rfile.readline().rstrip(b'\n'))
        except Exception:
            self.request.sendall(
                b'THIS IS A CRYPTOGRAPHIC CHALLENGE!!!\n')
            return

        pos = payment.rfind(b'&sign=')
        if pos == -1:
            self.request.sendall(b'Invalid order\n')
            return

        signature = payment[pos + 6:]
        if sha512(self.signkey+payment[:pos]).hexdigest().encode() != signature:
            self.request.sendall(b'Invalid order\n')
            return

        m = self.parse_qsl(payment[:pos])
        try:
            pname = m[b'product']
            price = int(m[b'price'])
        except (KeyError, ValueError, IndexError):
            self.request.sendall(b'Invalid order\n')
            return

        if price > self.money:
            self.request.sendall(b'Oops\n')
            return

        self.money -= price
        self.request.sendall(
            b'Transaction is completed. Your balance: $%d\n' % self.money)
        if pname == b'FLAG':
            print("{} solved the challenge".format(self.client_address[0]))
            self.request.sendall(b'Here is your flag: %s\n' % get_flag())
        else:
            self.request.sendall(
                b'%s will be delivered to your in-game mailbox soon\n' % pname)

    def parse_qsl(self, query):
        m = {}
        parts = query.split(b'&')
        for part in parts:
            key, val = part.split(b'=')
            m[key] = val
        return m


class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    pass


def main(argv):
    host, port = 'localhost', 8000

    if len(argv) == 2:
        port = int(argv[1])
    elif len(argv) >= 3:
        host, port = argv[1], int(argv[2])

    sys.stderr.write('Listening {}:{}\n'.format(host, port))
    server = ThreadedTCPServer((host, port), RequestHandler)
    server.daemon_threads = True
    server.allow_reuse_address = True
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
    server.server_close()


if __name__ == '__main__':
    main(sys.argv)
```

*ƒë√πa kh√¥ng zui tui ƒë√£ kƒÉng*

ok ng√≥ n√†o

**Problems:**
- Ch√∫ng ta v√¥ shop mua ƒë·ªì, v·ªõi s·ªë ti·ªÅn random trong kho·∫£ng t·ª´ 1 ƒë·∫øn 1999. Trong khi FLAG gi√° t·∫≠n 9999 l·∫≠n? Ph·∫£i t√¨m c√°ch mua th√¥i
- ·ªí, ƒë√¢y l√† th·ª© ta c·∫ßn ch√∫ √Ω trong h√†m *order*:
```
payment = b'product=%s&price=%d&time=%.02f' % (
            items[pid-1][0], items[pid-1][1], datetime.datetime.now().timestamp())
        signature = sha512(self.signkey+payment).hexdigest()
        payment += b'&sign=%s' % signature.encode()
```
- ·ªí ƒë√¢y l√† 1 b√†i v·ªÅ hash. C·ª• th·ªÉ l√† SHA-512. M√¨nh nghƒ© ngay ƒë·∫øn c√°ch t·∫•n c√¥ng g·ªçi l√† *hash length extension attack*. C√°c b·∫°n c√≥ th·ªÉ ƒë·ªçc hi·ªÉu c√°ch ho·∫°t ƒë·ªông c·ª• th·ªÉ ·ªü [link n√†y n√†y b·∫•m b·∫•m](https://github.com/iagox86/hash_extender).
- V·ªÅ ƒëo·∫°n signkey ƒë∆∞·ª£c ch√®n v√†o s·∫Ω c√≥ ƒë·ªô d√†i random t·ª´ 8 ƒë·∫øn 32, m√¨nh kh√¥ng c·∫ßn quan t√¢m ƒë·∫øn gi√° tr·ªã ƒë√≥ l√†m g√¨ v√¨ khi attack, m√¨nh s·∫Ω ƒë·∫©y h·∫øt ƒëo·∫°n signkey ƒë√≥ ƒëi. Do kh√¥ng bi·∫øt c·ª• th·ªÉ n√™n m√¨nh l·∫°i brute-force v·∫≠y üôÑ
- Ti·∫øp t·ª•c m√¨nh nh√≥ qua h√†m *parse_qsl*. Ch·ªó n√†y m·ª•c ƒë√≠ch t√°ch c√°c th√†nh ph·∫ßn ra th√¥i, m√¨nh s·∫Ω l·ª£i d·ª•ng ch·ªó n√†y ƒë·ªÉ attack v√†o, c·ª• th·ªÉ l√† th√™m chu·ªói "product=FLAG" sau khi ch·ªçn mua m√≥n h√†ng ƒë·∫ßu ti√™n! M√† m√≥n h√†ng ƒë·∫ßu ti√™n lu√¥n l√† gi√° 1ƒë, n√™n m√¨nh lu√¥n c√≥ th·ªÉ mua ƒë∆∞·ª£c üòÅ. Th√¨ sau khi m√¨nh truy·ªÅn chu·ªói sau khi th√™m "product=FLAG", h√†m *parse_qsl* s·∫Ω th·ª±c thi v√† m√≥n h√†ng m√¨nh mua s·∫Ω l√† FLAG, ch·ª© kh√¥ng ph·∫£i l√† m√≥n h√†ng ƒë·∫ßu ti√™n n·ªØa.


solve.py
```
from pwn import *
from base64 import b64encode, b64decode
from hashpumpy import hashpump

def parse_qsl(query):
    m = {}
    parts = query.split(b'&')
    for part in parts:
        key, val = part.split(b'=')
        m[key] = val
    return m

while True:
    io = remote('chal1.crypto.letspentest.org', 7000)

    io.recv()
    io.sendline(b'2')
    io.sendline(b'1')
    io.recvuntil(b'Your order: ')
    payment = io.recvline()
    io.recv()

    payment = b64decode(payment)
    signature = parse_qsl(payment)
    signature = signature[b'sign']

    payment = payment.split(b'&')
    del payment[3]
    payment = b'&'.join(payment)

    for i in range(8,33):
        new_signature, new_data = hashpump(signature, payment, '&product=FLAG', i)
        
        payload = new_data + b'&sign=' + new_signature.encode()
        payload = b64encode(payload)
        
        io.sendline(b'3')
        io.recv()
        io.sendline(payload)
        result = io.recvline()
        if b'Invalid order' in result:
            io.recv()
            continue
        else:
            #print(result)
            print(io.recvline())
            exit(0)
```

> **note:** m·∫•y anh em n√†o m√† ch·∫°y code n√†y th√¨ ph·∫£i qua ubuntu ho·∫∑c linux ch·∫°y nha, v√¨ m√¨nh d√πng th∆∞ vi·ªán hashpump ·∫•y

Sau 1 h·ªìi ch·∫°y.... flag s·∫Ω ƒë∆∞·ª£c tr·∫£ ra:

>FLAG: Flag{hashlengthextensionattack}

C√°m ∆°n c√°c anh em ƒë√£ ƒë·ªçc h·∫øt nha he he he he.

