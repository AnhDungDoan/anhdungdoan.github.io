---
layout: post
title: Down Under CTF 2021
date: 2021-09-27 00:00:00 +0300
description: WU Crypto # Add post description (optional)
img: DUCTF-panel.jpg # Add image post (optional)
tags: [Crypto, CTF] # add tag
---

# **DownUnderCTF2021**
# **Substitution Cipher I**
**Problem:**

*substitution-cipher-i.sage*

    def encrypt(msg, f):
        return ''.join(chr(f.substitute(c)) for c in msg)

    P.<x> = PolynomialRing(ZZ)
    f = 13*x^2 + 3*x + 7

    FLAG = open('./flag.txt', 'rb').read().strip()

    enc = encrypt(FLAG, f)
    print(enc)

*output.txt*

ÓÆ£ñø´ÓìÖñùìÔ¶≠∞ÜΩ™Éµ¢ôøÁñó´¢ã•Üõü¥É‰∂π¨ëΩËíµú≠±´¢ã™ÉµËíµü¥Éú≠±©ïëÁñó™≤≥ú≠±Á™áËíµ±´≥

**Solve:**

-   Gi·∫£i ph∆∞∆°ng tr√¨nh b·∫≠c 2 l√† xong, l·∫•y nghi·ªám nguy√™n d∆∞∆°ng :D

```
    import math

    flag = 'ÓÆ£ñø´ÓìÖñùìÔ¶≠∞ÜΩ™Éµ¢ôøÁñó´¢ã•Üõü¥É‰∂π¨ëΩËíµú≠±´¢ã™ÉµËíµü¥Éú≠±©ïëÁñó™≤≥ú≠±Á™áËíµ±´≥'

    ans = [60323, 55323, 57323, 58565, 55321, 57171, 63917, 55424, 56765, 55400, 56565, 55369, 56959, 30103, 55406, 56459, 55380, 56731, 55359, 56579, 19897, 55409, 56445, 33973, 55346, 57201, 55406, 56459, 55400, 56565, 33973, 55359, 56579, 55346, 57201, 55397, 56657, 30103, 55403, 56499, 55346, 57201, 31367, 33973, 55430, 57075]
    def get(x):
        return (-3+int(math.sqrt(9-4*13*(7-x))))//26

    for x in flag:
        print(chr(get(ord(x))), end = '')
```
        

**FLAG:**

> DUCTF{sh0uld\'v3_us3d_r0t_13}

# **Substitution Cipher II**

**Problem:**

*substitution-cipher-ii.sage*

    from string import ascii_lowercase, digits
    CHARSET = "DUCTF{}_!?'" + ascii_lowercase + digits
    n = len(CHARSET)

    def encrypt(msg, f):
        ct = ''
        for c in msg:
            ct += CHARSET[f.substitute(CHARSET.index(c))]
        return ct

    P.<x> = PolynomialRing(GF(n))
    f = P.random_element(6)

    FLAG = open('./flag.txt', 'r').read().strip()

    enc = encrypt(FLAG, f)
    print(enc)

*output.txt*

Ujyw5dnFofaou0au3nx3Cn84

**Solve**

Nh·∫≠n x√©t:

-   $f = P.randomelement(6)$ l√† h√†m random ra ƒëa th·ª©c b·∫≠c 6, nghƒ©a l√†
    $a*x^6 + b*x^5 + c*x^4 + d*x^3 + e*x^2 + f*x + g$

-   M√¨nh ƒëo√°n ƒë∆∞·ª£c FLAG c√≥ c√°c k√≠ t·ª± ƒë·∫ßu l√†: \'DUCTF{\' l·∫ßn l∆∞·ª£t n·∫±m ·ªü
    v·ªã tr√≠ trong CHARSET l√† 0, 1, 2, 3, 4, 5 =\> $g = 1$ (do trong
    encrypted th√¨ ch·ªØ c√°i ƒë·∫ßu ti√™n l√† \'U\' c√≥ index l√† 1 trong CHARSET)

-   V·ªõi ch·ªØ c√°i ti·∫øp theo trong FLAG: \'U\' (index trong CHARSET l√† 1)
    th√¨ ƒëa th·ª©c tr·ªü th√†nh: $a+b+c+d+e+f+1$ = 20 (do trong encrypted th√¨
    ch·ªØ c√°i ƒë·∫ßu ti√™n l√† \'j\' c√≥ index l√† 20 trong CHARSET)

=\> Brute force 5 bi·∫øn a, b, c, d, e, sau ƒë√≥ d·ª±a v√†o ph√©p t√≠nh tr√™n ƒë·ªÉ
t√¨m f ·ªü m·ªói l·∫ßn ch·∫°y, v√† g = 1, n·∫øu ƒëa th·ª©c ƒë√≥ cho ra d√£y k·∫øt qu·∫£ m·ªói
l·∫ßn m√¨nh ƒë∆∞a \'DUCTF\' == \'Ujyw5d\' th√¨ ƒë√≥ c√≥ kh·∫£ nƒÉng l√† ƒëa th·ª©c ƒë√∫ng

***code bruteforce:***

    for a in range(0,47):
        for b in range(0,47):
            for c in range(0,47):
                for d in range(0,47):
                    for e in range(0,47):
                        temp = (a+b+c+d+e+1) %47
                        if (temp < 20):
                            f = 20 - temp
                        else:
                            f = 67 - temp
                        ans = ""
                        for ch in FLAG:
                            x = CHARSET.index(ch)
                            fract = (a*pow(x,6) + b*pow(x,5) + c*pow(x,4) + d*pow(x,3) + e*pow(x,2) + f*x + 1) %47
                            ans = ans + CHARSET[fract]
                        if (ans == enc):
                            print(a,", ",b,", ",c,", ",d,", ",e,", ",f)

-\> V√† dƒ© nhi√™n s·∫Ω in ra ƒë∆∞·ª£c nhi·ªÅu k·∫øt qu·∫£ c·ªßa (a, b, c, d, e, f). Vi·ªác
c√≤n l·∫°i l√† th·ª≠ k·∫øt qu·∫£ n√†o khi ƒë∆∞a d√£y encrypted ra ƒë∆∞·ª£c 1 d√£y k·∫øt qu·∫£
c√≥ ƒë·ªô d√†i t∆∞∆°ng ƒë∆∞∆°ng l√† xong!

***code check***
```
    enc = "Ujyw5dnFofaou0au3nx3Cn84"
    flag = ""
    def cal_frac(x):
        fract = (a*pow(x,6) + b*pow(x,5) + c*pow(x,4) + d*pow(x,3) + e*pow(x,2) + f*x + 1) %47
        return fract

    for i in range(len(enc)):
        for x in CHARSET:
            if (CHARSET[cal_frac(CHARSET.index(x))] == enc[i]):
                flag += x
                break

    print(len(enc) == len(flag)))
    print(flag)
```

> FLAG: DUCTF{go0d_0l\'\_l4gr4ng3}

# **Break Me!**

**Problem:**

AES encryption challenge.

> nc pwn-2021.duc.tf 31914

*aes-ecb.py*
```
    #!/usr/bin/python3
    import sys
    import os
    from Crypto.Cipher import AES
    from base64 import b64encode

    bs = 16 # blocksize
    flag = open('flag.txt', 'rb').read().strip()
    key = open('key.txt', 'r').read().strip().encode() # my usual password

    def enc(pt):
        cipher = AES.new(key, AES.MODE_ECB)
        ct = cipher.encrypt(pad(pt+key))
        res = b64encode(ct).decode('utf-8')
        return res

    def pad(pt):
        while len(pt) % bs:
            pt += b'0'
        return (pt)

    def main():
        print('AES-128')
        while(1):
            msg = input('Enter plaintext:\n').strip()
            pt = flag + str.encode(msg)
            ct = enc(pt)
            print(ct)

    if __name__ == '__main__':
        main()
```

**Solve:**

M·∫•u ch·ªët b√†i n√†y l√† t√¨m key l√† decrypt l·∫°i l√† l·ª•m FLAG th√¥i!!! :D

Nh·∫≠n x√©t 1:

-   Khi m√¨nh kh√¥ng g·ª≠i g√¨ l√™n server, t·∫•t nhi√™n server s·∫Ω tr·∫£ v·ªÅ cho
    m√¨nh ƒëo·∫°n m√£ sau khi chuy·ªÉn base64 c·ªßa AES_ECB(\'flag + key\')
-   Khi m√¨nh g·ª≠i ƒë·∫°i 1 k√≠ t·ª± l√™n server, server s·∫Ω tr·∫£ v·ªÅ cho m√¨nh ƒëo·∫°n
    m√£ sau khi chuy·ªÉn base64 c·ªßa AES_ECB(\'flag + input + key +
    padding\')

=\> B·∫±ng m·∫Øt th∆∞·ªùng c√≥ th·ªÉ d·ªÖ d√†ng bi·∫øt ƒë∆∞·ª£c ƒë·ªô d√†i c·ªßa flag l√† 32, ƒë·ªô
d√†i c·ªßa key l√† 16.

Nh·∫≠n x√©t 2:

-   Do blocksize l√† 16, v·ªõi c∆° ch·∫ø ho·∫°t ƒë·ªông c·ªßa AES_ECB th√¨ n√≥ encrypt
    theo t·ª´ng block, n√™n m√¨nh t·∫°m s·∫Ω kh√¥ng quan t√¢m ƒë·∫øn 2 block
    ƒë·∫ßu(FLAG), m√¨nh ch·ªâ attack ƒë·ªÉ l·∫•y key, sau ƒë√≥ kh√¥i ph·ª•c l·∫°i FLAG

-   ![image.png](/assets/img/ductf-breakme.png)

-   Nh∆∞ h√¨nh tr√™n, m√¨nh s·∫Ω l·ª£i d·ª•ng block 3 v√† 5 ƒë·ªÉ brute force t·ª´ng k√≠
    t·ª± m·ªôt trong KEY, n·∫øu block 3 == block 5, nghƒ©a l√† k√≠ t·ª± ƒë√≥ ƒë√∫ng,
    sau ƒë√≥ m√¨nh brute k√≠ t·ª± ti·∫øp theo + c√°c k√≠ t·ª± ƒë√£ ƒë√∫ng s·∫µn tr∆∞·ªõc ƒë√≥


```
    from pwn import *
    import base64
    import sys
    import os
    from Crypto.Cipher import AES

    flag_key = '\xf0\xc0*\xde\x91\xac\xef\xf2\x93r\xfd\x1c\xde(\xeaL\x98o\xff?U\xf1\x00;\x97\xd4\xe42E;\xd9\x82\x9b\xc5\xd6v\x11\xb0%\xbd\xd9\xfc\x95\x98\xd8ik\x95'

    p = connect("pwn-2021.duc.tf", 31914)
    p.recvuntil(b'AES-128')

    for i in range(16):
        for j in range(33,127):
            p.recvuntil(b'Enter plaintext:')
            p.recvuntil(b'\n')
            char = chr(j)
            text = char + key + '0'*16
            p.sendline(text.encode())
            code = p.recvline()
            code = base64.b64decode(code)
            c1,c2,c3 = code[32:48], code[48:64], code[64:80]
            #p.recvline()
            if (c1 == c3):
                key = char+key
                print(key)
                break
 ```

M√¨nh l·ª•m ƒë∆∞·ª£c key = \'!*SECRETSOURCE*!\', sau ƒë√≥ decrypt l·∫°i th√¥i, d·ªÖ ·∫πc
vl
```
    key =   b'!_SECRETSOURCE_!'
    def main():
        cipher = AES.new(key, AES.MODE_ECB)
        ct = cipher.encrypt(flag)
        res = base64.b64encode(ct).decode('utf-8')
        return res


    flag = base64.b64decode(flag)

    cipher = AES.new(key, AES.MODE_ECB)
    enc = cipher.decrypt(base64.b64decode(flag))
    print(enc)
```

> FLAG: DUCTF{ECB_M0DE_K3YP4D_D474_L34k}

# **Treasure**

You and two friends have spent the past year playing an ARG that
promises valuable treasures to the first team to find three secret
shares scattered around the world. At long last, you have found all
three and are ready to combine the shares to figure out where the
treasure is. Of course, being the greedy individual you are, you plan to
use your cryptography skills to deceive your friends into thinking that
the treasure is in the middle of no where\...

> nc pwn-2021.duc.tf 31901

**Problem**

*treasure.py*
```
    #!/usr/bin/python3

    import re
    from Crypto.Util.number import long_to_bytes
    from Crypto.Random import random
    from secret import REAL_COORDS, FLAG_MSG

    FAKE_COORDS = 5754622710042474278449745314387128858128432138153608237186776198754180710586599008803960884
    p = 13318541149847924181059947781626944578116183244453569385428199356433634355570023190293317369383937332224209312035684840187128538690152423242800697049469987

    def create_shares(secret):
        r1 = random.randint(1, p - 1)
        r2 = random.randint(1, p - 1)
        s1 = r1*r2*secret % p
        s2 = r1*r1*r2*secret % p
        s3 = r1*r2*r2*secret % p
        return [s1, s2, s3]

    def reveal_secret(shares):
        s1, s2, s3 = shares
        secret = pow(s1, 3, p) * pow(s2*s3, -1, p) % p
        return secret

    def run_combiner(shares):
        try:
            your_share = int(input('Enter your share: '))
            return reveal_secret([your_share, shares[1], shares[2]])
        except:
            print('Invalid share')
            exit()

    def is_coords(s):
        try:
            return re.match(r'-?\d+\.\d+?, -?\d+\.\d+', long_to_bytes(s).decode())
        except:
            return False

    def main():
        shares = create_shares(REAL_COORDS)
        print(f'Your share is: {shares[0]}')
        print(f'Your two friends input their shares into the combiner and excitedly wait for you to do the same...')

        secret_coords = run_combiner(shares)
        print(f'The secret is revealed: {secret_coords}')
        if not is_coords(secret_coords):
            print('"Hey those don\'t look like coordinates!"')
            print('Your friends grow a bit suspicious, but you manage to convince them that you just entered a digit wrong. You decide to try again...')
        else:
            print('"Let\'s go get the treasure!!"')
            print('Your friends run off to the revealed location to look for the treasure...')
            exit()

        secret_coords = run_combiner(shares)
        if not is_coords(secret_coords):
            print('"This is way too sus!!"')
            exit()

        if secret_coords == FAKE_COORDS:
            print('You\'ve successfully deceived your friends!')

            try:
                real_coords = int(input('Now enter the real coords: '))
                if real_coords == REAL_COORDS:
                    print(FLAG_MSG)
                else:
                    print('Incorrect!')
            except:
                print('Incorrect!')
        else:
            print('You are a terrible trickster!')

    if __name__ == '__main__':
        main()
```

**Solve**

He he b√†i n√†y tui s·∫Ω kh√¥ng ghi code c·ª• th·ªÉ t·∫°i v√¨ tui l·∫•y k·∫øt qu·∫£ t·ª´
server l√† tui ch∆°i b·∫±ng m·∫•y s·ªë ƒë√≥ lu√¥n, ra ƒë∆∞·ª£c FLAG l√† th√¥i √†, n√™n l√†
ƒë∆∞a ra t·ª´ng b∆∞·ªõc gi·∫£i cho h√¨nh dung th√¥i nh√° ‡ºº „Å§ ‚óï\_‚óï ‡ºΩ„Å§

Nh·∫≠n x√©t c·ªß chu·ªëi 1:

-   Khi server h·ªèi: \'your share is: \' l·∫ßn ƒë·∫ßu, m√¨nh ƒëi·ªÅn c√°i qu·∫ßn qu√®
    g√¨ n√≥ c≈©ng ra REAL_COORDS. V√¨ sao √°? v√¨ nh√¨n v√¥ h√†m reveal_secret ƒëi
    c√°c ng√†i: $(r1*r2*REALCOORDS)^3 * (r1^3*r2^3*REALCOORDS^2)^(-1)$ l·∫°i
    ch·∫£ b·∫±ng REALCOORDS :-D
-   Bypass is_coord l·∫ßn ƒë·∫ßu tui g·ª≠i l√™n server s·ªë 1, th·ª±c ch·∫•t l√† g·ª≠i
    c√°i g√¨ tui c≈©ng kh√¥ng ch·∫Øc ch·∫Øn l·∫Øm ·ªü h√†m is_coords, h√¨nh nh∆∞ l√†
    check xem sau khi decode xong c√≥ ra c√°i t·ªça ƒë·ªô hay kh√¥ng ·∫•y, nh∆∞ng
    tui g·ª≠i s·ªë 1 n√≥ c≈©ng pass he he mlem

Nh·∫≠n x√©t c·ªß chu·ªëi 2:

-   Gi·ªù m·ªõi cƒÉng n√®, gi·ªù m√¨nh ph·∫£i g·ª≠i l√™n server 1 c√°i s·ªë n√†o ƒë√≥, sau
    khi s·ªë ƒë√≥ k·∫øt h·ª£p v·ªõi s2 v√† s3 (ƒë∆∞·ª£c random) ƒë·ªÉ n√≥ return t·ª´ h√†m
    reveal_secret ra 1 s·ªë = FAKE_COORDS m√† m√¨nh bi·∫øt s·∫µn.

-   Th√¨ reveal_secret = $(<input>*REALCOORDS)^3 * (r1^3*r2^3*REALCOORDS^2)^(-1)$. V·∫≠y b√¢y
    gi·ªù m√¨nh ch·ªâ c·∫ßn nh·∫≠p v√†o 1 sao cho v·∫ø ƒë·∫ßu tr∆∞·ªõc d·∫•u $*$ n√≥ tr·ªü
    th√†nh $(r1^3*r2^3*REALCOORDS^2 * FAKECOORDS)$ l√† xong, ƒë√∫ng hok üòé

-   √Ä qu√™n, nh·ªõ t√¨m s·ªë l√†m sao n√≥ \^3 %p == FAKECOORDS


```
    for i in range(100000):
        temp = FAKE_COORDS + p*i
        b, check = gmpy2.iroot(temp, 3)
        if (check == True):
            print("b = ", b)
            break
```

-   M√¨nh l·∫ßn l∆∞·ª£t t√≠nh c√°c gi√° tr·ªã: $REALCOORDS^(-1)$,
    $REALCOORDS^(2/3)$, r·ªìi nh√¢n c√°c th√†nh ph·∫ßn t·ª´ output ban ƒë·∫ßu m√¨nh
    nh·∫≠n ƒë∆∞·ª£c l·∫ßn ƒë·∫ßu ti√™n ($r1*r2*REALCOORDS$) l√† l·ª•m ƒë∆∞·ª£c flag


```
    print('%.15f' % pow(REAL_COORDS,2/3))

    temp = pow(m,3)*REAL_COORDS_1 %p
    d = inverse(3, p-1)
    msg = pow(temp, d, p)
```

> FLAG:
> DUCTF{m4yb3_th3_r34L_tr34sur3_w4s_th3_fr13nDs_w3_m4d3_al0ng_Th3_W4y\...\....}

Ph·∫ßn n√†y kh√¥ng n√™n ƒë·ªçc nh∆∞ng n·∫øu c√°c anh hai n√†o th·∫Øc m·∫Øc em code c√°i
qu·∫ßn qu√® g√¨ ·ªü b√†i n√†y th√¨ full ·ªü ƒë√¢y, em t·ªõi ƒë√¢u em l√†m t·ªõi ƒë√≥ gi·ªù ƒë·ªçc
l·∫°i c√≤n l√∫ m√† :v. Nh∆∞ng v·ªÅ c∆° b·∫£n √Ω t∆∞·ªüng nh∆∞ tr√™n n·∫øu m√† t·ª´ng th·ª≠ gi·∫£i
b√†i n√†y c√≥ ƒë∆∞·ª£c hay kh√¥ng ƒë∆∞·ª£c th√¨ ƒë·ªçc qua √Ω t∆∞·ªüng tr√™n ch·∫Øc l√† s·∫Ω gi·∫£i
ƒëc 100% ƒë√≥ ü§°
```
    import re
    from Crypto.Util.number import *
    from Crypto.Random import random
    import gmpy2

    REAL_COORDS = 5756627544102572649201219381096443309301530404084814366157678459246004007288774904822314549
    FAKE_COORDS = 5754622710042474278449745314387128858128432138153608237186776198754180710586599008803960884
    p = 13318541149847924181059947781626944578116183244453569385428199356433634355570023190293317369383937332224209312035684840187128538690152423242800697049469987
    REAL_COORDS2_3 = 3212023797359070207618890013558990479334108558649943801200640
    REAL_COORDS_1 = 3611972407916542175266075914158485498567096639014910771412413427552155406084059648812480111141112665427480798617032727444845994871280603904723436033038518

    def is_coords(s):
        try:
            return re.match(r'-?\d+\.\d+?, -?\d+\.\d+', long_to_bytes(s).decode())
        except:
            return False

    print(long_to_bytes(REAL_COORDS))
    print(long_to_bytes(FAKE_COORDS))
    for i in range(100000):
        temp = FAKE_COORDS + p*i
        b, check = gmpy2.iroot(temp, 3)
        if (check == True):
            print("b = ", b)
            break

    m = 2869341224917332313009265312495227025712569621383110354786034944049884444898065996165640916544755306105486353713866995648230401728598018943081224642657436
    # print(pow(REAL_COORDS *REAL_COORDS_1 * REAL_COORDS2_3, 3, p))
    # print('%.15f' % pow(REAL_COORDS,2/3))

    # print(pow(REAL_COORDS,2))
    # print(pow(3212023797359095191387490291951978689715826708825012842462276,3))
    temp = pow(m,3)*REAL_COORDS_1 %p
    d = inverse(3, p-1)
    msg = pow(temp, d, p)
    msg = 10954258416986940965254352563448744134121105790960391992791908032462708379320860571422885027991408179735966466488299908149056949839631488091514796075876201
    print(msg)
    print(pow(m,3)*REAL_COORDS_1 %p)

    #msg * reveal
```

C√°m ∆°n C√°m ∆°n C√°m ∆°n x3.14 üôàüôàüôàüôàüôà
