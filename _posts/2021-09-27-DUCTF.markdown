---
layout: post
title: Down Under CTF 2021
date: 2021-09-27 00:00:00 +0300
description: WU Crypto # Add post description (optional)
img: software.jpg # Add image post (optional)
tags: [Productivity, Software] # add tag
---

# **DownUnderCTF2021**
# **Substitution Cipher I**
**Problem:**

*substitution-cipher-i.sage*

    def encrypt(msg, f):
        return ''.join(chr(f.substitute(c)) for c in msg)

    P.<x> = PolynomialRing(ZZ)
    f = 13*x^2 + 3*x + 7

    FLAG = open('./flag.txt', 'rb').read().strip()

    enc = encrypt(FLAG, f)
    print(enc)

*output.txt*

î®£ğ–¿«î“…ğ–“ï¦­ğ°†½ğªƒµğ¢™¿ç–—ğ«¢‹ğ¥†›ğŸ´ƒä¶¹ğ¬‘½è’µğœ­±ğ«¢‹ğªƒµè’µğŸ´ƒğœ­±ğ©•‘ç–—ğª²³ğœ­±çª‡è’µğ±«³

**Solve:**

-   Giáº£i phÆ°Æ¡ng trÃ¬nh báº­c 2 lÃ  xong, láº¥y nghiá»‡m nguyÃªn dÆ°Æ¡ng :D

```{=html}
<!-- -->
```
    import math

    flag = 'î®£ğ–¿«î“…ğ–“ï¦­ğ°†½ğªƒµğ¢™¿ç–—ğ«¢‹ğ¥†›ğŸ´ƒä¶¹ğ¬‘½è’µğœ­±ğ«¢‹ğªƒµè’µğŸ´ƒğœ­±ğ©•‘ç–—ğª²³ğœ­±çª‡è’µğ±«³'

    ans = [60323, 55323, 57323, 58565, 55321, 57171, 63917, 55424, 56765, 55400, 56565, 55369, 56959, 30103, 55406, 56459, 55380, 56731, 55359, 56579, 19897, 55409, 56445, 33973, 55346, 57201, 55406, 56459, 55400, 56565, 33973, 55359, 56579, 55346, 57201, 55397, 56657, 30103, 55403, 56499, 55346, 57201, 31367, 33973, 55430, 57075]
    def get(x):
        return (-3+int(math.sqrt(9-4*13*(7-x))))//26

    for x in flag:
        print(chr(get(ord(x))), end = '')
        

**FLAG:**

> DUCTF{sh0uld\'v3_us3d_r0t_13}

# **Substitution Cipher II**

**Problem:**

*substitution-cipher-ii.sage*

    from string import ascii_lowercase, digits
    CHARSET = "DUCTF{}_!?'" + ascii_lowercase + digits
    n = len(CHARSET)

    def encrypt(msg, f):
        ct = ''
        for c in msg:
            ct += CHARSET[f.substitute(CHARSET.index(c))]
        return ct

    P.<x> = PolynomialRing(GF(n))
    f = P.random_element(6)

    FLAG = open('./flag.txt', 'r').read().strip()

    enc = encrypt(FLAG, f)
    print(enc)

*output.txt*

Ujyw5dnFofaou0au3nx3Cn84

**Solve**

Nháº­n xÃ©t:

-   $f = P.randomelement(6)$ lÃ  hÃ m random ra Ä‘a thá»©c báº­c 6, nghÄ©a lÃ 
    $a*x^6 + b*x^5 + c*x^4 + d*x^3 + e*x^2 + f*x + g$

-   MÃ¬nh Ä‘oÃ¡n Ä‘Æ°á»£c FLAG cÃ³ cÃ¡c kÃ­ tá»± Ä‘áº§u lÃ : \'DUCTF{\' láº§n lÆ°á»£t náº±m á»Ÿ
    vá»‹ trÃ­ trong CHARSET lÃ  0, 1, 2, 3, 4, 5 =\> $g = 1$ (do trong
    encrypted thÃ¬ chá»¯ cÃ¡i Ä‘áº§u tiÃªn lÃ  \'U\' cÃ³ index lÃ  1 trong CHARSET)

-   Vá»›i chá»¯ cÃ¡i tiáº¿p theo trong FLAG: \'U\' (index trong CHARSET lÃ  1)
    thÃ¬ Ä‘a thá»©c trá»Ÿ thÃ nh: $a+b+c+d+e+f+1$ = 20 (do trong encrypted thÃ¬
    chá»¯ cÃ¡i Ä‘áº§u tiÃªn lÃ  \'j\' cÃ³ index lÃ  20 trong CHARSET)

=\> Brute force 5 biáº¿n a, b, c, d, e, sau Ä‘Ã³ dá»±a vÃ o phÃ©p tÃ­nh trÃªn Ä‘á»ƒ
tÃ¬m f á»Ÿ má»—i láº§n cháº¡y, vÃ  g = 1, náº¿u Ä‘a thá»©c Ä‘Ã³ cho ra dÃ£y káº¿t quáº£ má»—i
láº§n mÃ¬nh Ä‘Æ°a \'DUCTF\' == \'Ujyw5d\' thÃ¬ Ä‘Ã³ cÃ³ kháº£ nÄƒng lÃ  Ä‘a thá»©c Ä‘Ãºng

***code bruteforce:***

    for a in range(0,47):
        for b in range(0,47):
            for c in range(0,47):
                for d in range(0,47):
                    for e in range(0,47):
                        temp = (a+b+c+d+e+1) %47
                        if (temp < 20):
                            f = 20 - temp
                        else:
                            f = 67 - temp
                        ans = ""
                        for ch in FLAG:
                            x = CHARSET.index(ch)
                            fract = (a*pow(x,6) + b*pow(x,5) + c*pow(x,4) + d*pow(x,3) + e*pow(x,2) + f*x + 1) %47
                            ans = ans + CHARSET[fract]
                        if (ans == enc):
                            print(a,", ",b,", ",c,", ",d,", ",e,", ",f)

-\> VÃ  dÄ© nhiÃªn sáº½ in ra Ä‘Æ°á»£c nhiá»u káº¿t quáº£ cá»§a (a, b, c, d, e, f). Viá»‡c
cÃ²n láº¡i lÃ  thá»­ káº¿t quáº£ nÃ o khi Ä‘Æ°a dÃ£y encrypted ra Ä‘Æ°á»£c 1 dÃ£y káº¿t quáº£
cÃ³ Ä‘á»™ dÃ i tÆ°Æ¡ng Ä‘Æ°Æ¡ng lÃ  xong!

***code check***

    enc = "Ujyw5dnFofaou0au3nx3Cn84"
    flag = ""
    def cal_frac(x):
        fract = (a*pow(x,6) + b*pow(x,5) + c*pow(x,4) + d*pow(x,3) + e*pow(x,2) + f*x + 1) %47
        return fract

    for i in range(len(enc)):
        for x in CHARSET:
            if (CHARSET[cal_frac(CHARSET.index(x))] == enc[i]):
                flag += x
                break

    print(len(enc) == len(flag)))
    print(flag)

> FLAG: DUCTF{go0d_0l\'\_l4gr4ng3}

# **Break Me!**

**Problem:**

AES encryption challenge.

> nc pwn-2021.duc.tf 31914

*aes-ecb.py*

    #!/usr/bin/python3
    import sys
    import os
    from Crypto.Cipher import AES
    from base64 import b64encode

    bs = 16 # blocksize
    flag = open('flag.txt', 'rb').read().strip()
    key = open('key.txt', 'r').read().strip().encode() # my usual password

    def enc(pt):
        cipher = AES.new(key, AES.MODE_ECB)
        ct = cipher.encrypt(pad(pt+key))
        res = b64encode(ct).decode('utf-8')
        return res

    def pad(pt):
        while len(pt) % bs:
            pt += b'0'
        return (pt)

    def main():
        print('AES-128')
        while(1):
            msg = input('Enter plaintext:\n').strip()
            pt = flag + str.encode(msg)
            ct = enc(pt)
            print(ct)

    if __name__ == '__main__':
        main()

**Solve:**

Máº¥u chá»‘t bÃ i nÃ y lÃ  tÃ¬m key lÃ  decrypt láº¡i lÃ  lá»¥m FLAG thÃ´i!!! :D

Nháº­n xÃ©t 1:

-   Khi mÃ¬nh khÃ´ng gá»­i gÃ¬ lÃªn server, táº¥t nhiÃªn server sáº½ tráº£ vá» cho
    mÃ¬nh Ä‘oáº¡n mÃ£ sau khi chuyá»ƒn base64 cá»§a AES_ECB(\'flag + key\')
-   Khi mÃ¬nh gá»­i Ä‘áº¡i 1 kÃ­ tá»± lÃªn server, server sáº½ tráº£ vá» cho mÃ¬nh Ä‘oáº¡n
    mÃ£ sau khi chuyá»ƒn base64 cá»§a AES_ECB(\'flag + input + key +
    padding\')

=\> Báº±ng máº¯t thÆ°á»ng cÃ³ thá»ƒ dá»… dÃ ng biáº¿t Ä‘Æ°á»£c Ä‘á»™ dÃ i cá»§a flag lÃ  32, Ä‘á»™
dÃ i cá»§a key lÃ  16.

Nháº­n xÃ©t 2:

-   Do blocksize lÃ  16, vá»›i cÆ¡ cháº¿ hoáº¡t Ä‘á»™ng cá»§a AES_ECB thÃ¬ nÃ³ encrypt
    theo tá»«ng block, nÃªn mÃ¬nh táº¡m sáº½ khÃ´ng quan tÃ¢m Ä‘áº¿n 2 block
    Ä‘áº§u(FLAG), mÃ¬nh chá»‰ attack Ä‘á»ƒ láº¥y key, sau Ä‘Ã³ khÃ´i phá»¥c láº¡i FLAG

-   ![image.png](199ca84dd1d748edaf01c85132b79517159936ad89484e6a27115e54572789b18c07c9d7.png)

-   NhÆ° hÃ¬nh trÃªn, mÃ¬nh sáº½ lá»£i dá»¥ng block 3 vÃ  5 Ä‘á»ƒ brute force tá»«ng kÃ­
    tá»± má»™t trong KEY, náº¿u block 3 == block 5, nghÄ©a lÃ  kÃ­ tá»± Ä‘Ã³ Ä‘Ãºng,
    sau Ä‘Ã³ mÃ¬nh brute kÃ­ tá»± tiáº¿p theo + cÃ¡c kÃ­ tá»± Ä‘Ã£ Ä‘Ãºng sáºµn trÆ°á»›c Ä‘Ã³


```
    from pwn import *
    import base64
    import sys
    import os
    from Crypto.Cipher import AES

    flag_key = '\xf0\xc0*\xde\x91\xac\xef\xf2\x93r\xfd\x1c\xde(\xeaL\x98o\xff?U\xf1\x00;\x97\xd4\xe42E;\xd9\x82\x9b\xc5\xd6v\x11\xb0%\xbd\xd9\xfc\x95\x98\xd8ik\x95'

    p = connect("pwn-2021.duc.tf", 31914)
    p.recvuntil(b'AES-128')

    for i in range(16):
        for j in range(33,127):
            p.recvuntil(b'Enter plaintext:')
            p.recvuntil(b'\n')
            char = chr(j)
            text = char + key + '0'*16
            p.sendline(text.encode())
            code = p.recvline()
            code = base64.b64decode(code)
            c1,c2,c3 = code[32:48], code[48:64], code[64:80]
            #p.recvline()
            if (c1 == c3):
                key = char+key
                print(key)
                break
 ```

MÃ¬nh lá»¥m Ä‘Æ°á»£c key = \'!*SECRETSOURCE*!\', sau Ä‘Ã³ decrypt láº¡i thÃ´i, dá»… áº¹c
vl

    key =   b'!_SECRETSOURCE_!'
    def main():
        cipher = AES.new(key, AES.MODE_ECB)
        ct = cipher.encrypt(flag)
        res = base64.b64encode(ct).decode('utf-8')
        return res


    flag = base64.b64decode(flag)

    cipher = AES.new(key, AES.MODE_ECB)
    enc = cipher.decrypt(base64.b64decode(flag))
    print(enc)

> FLAG: DUCTF{ECB_M0DE_K3YP4D_D474_L34k}

# **Treasure**

You and two friends have spent the past year playing an ARG that
promises valuable treasures to the first team to find three secret
shares scattered around the world. At long last, you have found all
three and are ready to combine the shares to figure out where the
treasure is. Of course, being the greedy individual you are, you plan to
use your cryptography skills to deceive your friends into thinking that
the treasure is in the middle of no where\...

> nc pwn-2021.duc.tf 31901

**Problem**

*treasure.py*

    #!/usr/bin/python3

    import re
    from Crypto.Util.number import long_to_bytes
    from Crypto.Random import random
    from secret import REAL_COORDS, FLAG_MSG

    FAKE_COORDS = 5754622710042474278449745314387128858128432138153608237186776198754180710586599008803960884
    p = 13318541149847924181059947781626944578116183244453569385428199356433634355570023190293317369383937332224209312035684840187128538690152423242800697049469987

    def create_shares(secret):
        r1 = random.randint(1, p - 1)
        r2 = random.randint(1, p - 1)
        s1 = r1*r2*secret % p
        s2 = r1*r1*r2*secret % p
        s3 = r1*r2*r2*secret % p
        return [s1, s2, s3]

    def reveal_secret(shares):
        s1, s2, s3 = shares
        secret = pow(s1, 3, p) * pow(s2*s3, -1, p) % p
        return secret

    def run_combiner(shares):
        try:
            your_share = int(input('Enter your share: '))
            return reveal_secret([your_share, shares[1], shares[2]])
        except:
            print('Invalid share')
            exit()

    def is_coords(s):
        try:
            return re.match(r'-?\d+\.\d+?, -?\d+\.\d+', long_to_bytes(s).decode())
        except:
            return False

    def main():
        shares = create_shares(REAL_COORDS)
        print(f'Your share is: {shares[0]}')
        print(f'Your two friends input their shares into the combiner and excitedly wait for you to do the same...')

        secret_coords = run_combiner(shares)
        print(f'The secret is revealed: {secret_coords}')
        if not is_coords(secret_coords):
            print('"Hey those don\'t look like coordinates!"')
            print('Your friends grow a bit suspicious, but you manage to convince them that you just entered a digit wrong. You decide to try again...')
        else:
            print('"Let\'s go get the treasure!!"')
            print('Your friends run off to the revealed location to look for the treasure...')
            exit()

        secret_coords = run_combiner(shares)
        if not is_coords(secret_coords):
            print('"This is way too sus!!"')
            exit()

        if secret_coords == FAKE_COORDS:
            print('You\'ve successfully deceived your friends!')

            try:
                real_coords = int(input('Now enter the real coords: '))
                if real_coords == REAL_COORDS:
                    print(FLAG_MSG)
                else:
                    print('Incorrect!')
            except:
                print('Incorrect!')
        else:
            print('You are a terrible trickster!')

    if __name__ == '__main__':
        main()
:::

::: {.cell .markdown id="FEn3HEm_-CZQ"}
**Solve**

He he bÃ i nÃ y tui sáº½ khÃ´ng ghi code cá»¥ thá»ƒ táº¡i vÃ¬ tui láº¥y káº¿t quáº£ tá»«
server lÃ  tui chÆ¡i báº±ng máº¥y sá»‘ Ä‘Ã³ luÃ´n, ra Ä‘Æ°á»£c FLAG lÃ  thÃ´i Ã , nÃªn lÃ 
Ä‘Æ°a ra tá»«ng bÆ°á»›c giáº£i cho hÃ¬nh dung thÃ´i nhÃ¡ à¼¼ ã¤ â—•\_â—• à¼½ã¤

Nháº­n xÃ©t cá»§ chuá»‘i 1:

-   Khi server há»i: \'your share is: \' láº§n Ä‘áº§u, mÃ¬nh Ä‘iá»n cÃ¡i quáº§n quÃ¨
    gÃ¬ nÃ³ cÅ©ng ra REAL_COORDS. VÃ¬ sao Ã¡? vÃ¬ nhÃ¬n vÃ´ hÃ m reveal_secret Ä‘i
    cÃ¡c ngÃ i: $(r1*r2*REALCOORDS)^3 * (r1^3*r2^3*REALCOORDS^2)^(-1)$ láº¡i
    cháº£ báº±ng REALCOORDS :-D
-   Bypass is_coord láº§n Ä‘áº§u tui gá»­i lÃªn server sá»‘ 1, thá»±c cháº¥t lÃ  gá»­i
    cÃ¡i gÃ¬ tui cÅ©ng khÃ´ng cháº¯c cháº¯n láº¯m á»Ÿ hÃ m is_coords, hÃ¬nh nhÆ° lÃ 
    check xem sau khi decode xong cÃ³ ra cÃ¡i tá»a Ä‘á»™ hay khÃ´ng áº¥y, nhÆ°ng
    tui gá»­i sá»‘ 1 nÃ³ cÅ©ng pass he he mlem

Nháº­n xÃ©t cá»§ chuá»‘i 2:

-   Giá» má»›i cÄƒng nÃ¨, giá» mÃ¬nh pháº£i gá»­i lÃªn server 1 cÃ¡i sá»‘ nÃ o Ä‘Ã³, sau
    khi sá»‘ Ä‘Ã³ káº¿t há»£p vá»›i s2 vÃ  s3 (Ä‘Æ°á»£c random) Ä‘á»ƒ nÃ³ return tá»« hÃ m
    reveal_secret ra 1 sá»‘ = FAKE_COORDS mÃ  mÃ¬nh biáº¿t sáºµn.

-   ThÃ¬ reveal_secret =
    $(<input>*REALCOORDS)^3 * (r1^3*r2^3*REALCOORDS^2)^(-1)$. Váº­y bÃ¢y
    giá» mÃ¬nh chá»‰ cáº§n nháº­p vÃ o 1 sao cho váº¿ Ä‘áº§u trÆ°á»›c dáº¥u $*$ nÃ³ trá»Ÿ
    thÃ nh $(r1^3*r2^3*REALCOORDS^2 * FAKECOORDS)$ lÃ  xong, Ä‘Ãºng hok ğŸ˜

-   Ã€ quÃªn, nhá»› tÃ¬m sá»‘ lÃ m sao nÃ³ \^3 %p == FAKECOORDS

```{=html}
<!-- -->
```
    for i in range(100000):
        temp = FAKE_COORDS + p*i
        b, check = gmpy2.iroot(temp, 3)
        if (check == True):
            print("b = ", b)
            break

-   MÃ¬nh láº§n lÆ°á»£t tÃ­nh cÃ¡c giÃ¡ trá»‹: $REALCOORDS^(-1)$,
    $REALCOORDS^(2/3)$, rá»“i nhÃ¢n cÃ¡c thÃ nh pháº§n tá»« output ban Ä‘áº§u mÃ¬nh
    nháº­n Ä‘Æ°á»£c láº§n Ä‘áº§u tiÃªn ($r1*r2*REALCOORDS$) lÃ  lá»¥m Ä‘Æ°á»£c flag

```{=html}
<!-- -->
```
    print('%.15f' % pow(REAL_COORDS,2/3))

    temp = pow(m,3)*REAL_COORDS_1 %p
    d = inverse(3, p-1)
    msg = pow(temp, d, p)

> FLAG:
> DUCTF{m4yb3_th3_r34L_tr34sur3_w4s_th3_fr13nDs_w3_m4d3_al0ng_Th3_W4y\...\....}

Pháº§n nÃ y khÃ´ng nÃªn Ä‘á»c nhÆ°ng náº¿u cÃ¡c anh hai nÃ o tháº¯c máº¯c em code cÃ¡i
quáº§n quÃ¨ gÃ¬ á»Ÿ bÃ i nÃ y thÃ¬ full á»Ÿ Ä‘Ã¢y, em tá»›i Ä‘Ã¢u em lÃ m tá»›i Ä‘Ã³ giá» Ä‘á»c
láº¡i cÃ²n lÃº mÃ  :v. NhÆ°ng vá» cÆ¡ báº£n Ã½ tÆ°á»Ÿng nhÆ° trÃªn náº¿u mÃ  tá»«ng thá»­ giáº£i
bÃ i nÃ y cÃ³ Ä‘Æ°á»£c hay khÃ´ng Ä‘Æ°á»£c thÃ¬ Ä‘á»c qua Ã½ tÆ°á»Ÿng trÃªn cháº¯c lÃ  sáº½ giáº£i
Ä‘c 100% Ä‘Ã³ ğŸ¤¡

    import re
    from Crypto.Util.number import *
    from Crypto.Random import random
    import gmpy2

    REAL_COORDS = 5756627544102572649201219381096443309301530404084814366157678459246004007288774904822314549
    FAKE_COORDS = 5754622710042474278449745314387128858128432138153608237186776198754180710586599008803960884
    p = 13318541149847924181059947781626944578116183244453569385428199356433634355570023190293317369383937332224209312035684840187128538690152423242800697049469987
    REAL_COORDS2_3 = 3212023797359070207618890013558990479334108558649943801200640
    REAL_COORDS_1 = 3611972407916542175266075914158485498567096639014910771412413427552155406084059648812480111141112665427480798617032727444845994871280603904723436033038518

    def is_coords(s):
        try:
            return re.match(r'-?\d+\.\d+?, -?\d+\.\d+', long_to_bytes(s).decode())
        except:
            return False

    print(long_to_bytes(REAL_COORDS))
    print(long_to_bytes(FAKE_COORDS))
    for i in range(100000):
        temp = FAKE_COORDS + p*i
        b, check = gmpy2.iroot(temp, 3)
        if (check == True):
            print("b = ", b)
            break

    m = 2869341224917332313009265312495227025712569621383110354786034944049884444898065996165640916544755306105486353713866995648230401728598018943081224642657436
    # print(pow(REAL_COORDS *REAL_COORDS_1 * REAL_COORDS2_3, 3, p))
    # print('%.15f' % pow(REAL_COORDS,2/3))

    # print(pow(REAL_COORDS,2))
    # print(pow(3212023797359095191387490291951978689715826708825012842462276,3))
    temp = pow(m,3)*REAL_COORDS_1 %p
    d = inverse(3, p-1)
    msg = pow(temp, d, p)
    msg = 10954258416986940965254352563448744134121105790960391992791908032462708379320860571422885027991408179735966466488299908149056949839631488091514796075876201
    print(msg)
    print(pow(m,3)*REAL_COORDS_1 %p)

    #msg * reveal


CÃ¡m Æ¡n CÃ¡m Æ¡n CÃ¡m Æ¡n x3.14 ğŸ™ˆğŸ™ˆğŸ™ˆğŸ™ˆğŸ™ˆ
